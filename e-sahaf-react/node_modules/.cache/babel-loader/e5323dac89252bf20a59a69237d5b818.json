{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _elementType = _interopRequireDefault(require(\"prop-types-extra/lib/elementType\"));\n\nvar _topeka = require(\"topeka\");\n\nvar _warning = _interopRequireDefault(require(\"warning\"));\n\nvar _memoizeOne = _interopRequireDefault(require(\"memoize-one\"));\n\nvar _shallowequal = _interopRequireDefault(require(\"shallowequal\"));\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _isNativeType = _interopRequireDefault(require(\"./utils/isNativeType\"));\n\nvar _ErrorUtils = require(\"./utils/ErrorUtils\");\n\nvar _Contexts = require(\"./Contexts\");\n\nvar _createEventHandler = _interopRequireDefault(require(\"./utils/createEventHandler\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction notify(handler, args) {\n  handler && handler.apply(void 0, args);\n}\n\nfunction resolveToNativeType(type) {\n  if (type === 'boolean') return 'checkbox';\n  return (0, _isNativeType.default)(type) ? type : 'text';\n}\n\nfunction getValueProps(type, value, props) {\n  if (value == null) value = '';\n\n  switch (type) {\n    case 'radio':\n    case 'checkbox':\n      return {\n        value: props.value,\n        checked: value\n      };\n\n    case 'file':\n      return {\n        value: ''\n      };\n\n    default:\n      return {\n        value: value\n      };\n  }\n}\n\nfunction isFilterErrorsEqual(_ref, _ref2) {\n  var a = _ref[0];\n  var b = _ref2[0];\n  var isEqual = (a.errors === b.errors || (0, _shallowequal.default)(a.errors, b.errors)) && a.names === b.names && a.mapErrors === b.mapErrors; // !isEqual && console.log('filter equalg cm \"\"', a.errors, b.errors)\n\n  return isEqual;\n}\n/**\n * The Field Component renders a form control and handles input value updates and validations.\n * Changes to the Field value are automatically propagated back up to the containing Form\n * Component.\n *\n * Fields provide a light abstraction over normal input components where values and onChange handlers\n * are take care of for you. Beyond that they just render the input for their type, Fields whille pass along\n * any props and children to the input so you can easily configure new input types.\n *\n * ```jsx { \"editable\": true }\n * <Form\n *   noValidate\n *   schema={modelSchema}\n *   defaultValue={{\n *     name: { first: 'Sally'},\n *     colorID: 0\n *   }}\n * >\n *     <label htmlFor=\"example-firstName\">Name</label>\n *     <Form.Field\n *       name='name.first'\n *       placeholder='First name'\n *       id=\"example-firstName\"\n *     />\n *     <label htmlFor=\"example-color\">Favorite Color</label>\n *     <Form.Field\n *       as='select'\n *       name='colorId'\n *       id=\"example-color\"\n *     >\n *       <option value={0}>Red</option>\n *       <option value={1}>Yellow</option>\n *       <option value={2}>Blue</option>\n *       <option value={3}>other</option>\n *     </Form.Field>\n *   <Form.Submit type='submit'>Submit</Form.Submit>\n * </Form>\n * ```\n *\n * In addition to injecting Field components with events and the field `value`, a\n * special prop called `meta` is also provided to all Field renderer components. `meta`\n * contains a bunch of helpful context as well some methods for doing advanced field operations.\n *\n * ```ts\n * interface Meta {\n *   value: any;                // the Field Value\n *   valid: boolean;            // Whether the field is currently valid\n *   invalid: boolean;          // inverse of valid\n *   touched: boolean:          // whether the field has been touched yet\n *   errors: ErrorObjectMap;    // the errors for this field and any neted fields\n *   schema?: YupSchema;        // The schema for this field\n *   context: YupSchemaContext; // the yup context object\n *   // onError allows manually _replacing_ errors for the Field `name`\n *   // any existing errors for this path will be removed first\n *   onError(errors: ErrorObjectMap): void\n * }\n * ```\n *\n */\n\n\nvar Field =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(Field, _React$PureComponent);\n\n  function Field() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n\n    _this.handleFieldError = function (errors) {\n      var _this$props = _this.props,\n          name = _this$props.name,\n          actions = _this$props.actions;\n      return actions.onFieldError(name, errors);\n    };\n\n    _this.eventHandlers = {};\n    _this.getEventHandlers = (0, _createEventHandler.default)(function (event) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        notify(_this.props[event], args);\n        notify(_this.props.bindingProps[event], args);\n\n        _this.handleValidateField(event, args);\n      };\n    });\n    _this.memoFilterAndMapErrors = (0, _memoizeOne.default)(_ErrorUtils.filterAndMapErrors, isFilterErrorsEqual);\n    return _this;\n  }\n\n  var _proto = Field.prototype;\n\n  _proto.buildMeta = function buildMeta() {\n    var _this$props2 = this.props,\n        name = _this$props2.name,\n        touched = _this$props2.touched,\n        exclusive = _this$props2.exclusive,\n        errors = _this$props2.errors,\n        actions = _this$props2.actions,\n        yupContext = _this$props2.yupContext,\n        submits = _this$props2.submits,\n        bindingProps = _this$props2.bindingProps,\n        _this$props2$errorCla = _this$props2.errorClass,\n        errorClass = _this$props2$errorCla === void 0 ? _config.default.errorClass : _this$props2$errorCla;\n    var schema;\n\n    try {\n      schema = actions.getSchemaForPath && name && actions.getSchemaForPath(name);\n    } catch (err) {}\n    /* ignore */\n    // prettier-ignore\n\n\n    var meta = _extends({\n      schema: schema,\n      touched: touched,\n      errorClass: errorClass,\n      context: yupContext,\n      onError: this.handleFieldError\n    }, submits);\n\n    var filteredErrors = this.memoFilterAndMapErrors({\n      errors: errors,\n      names: name,\n      mapErrors: !exclusive ? _ErrorUtils.inclusiveMapErrors : undefined\n    });\n    meta.errors = filteredErrors;\n    meta.invalid = !!Object.keys(filteredErrors).length;\n    meta.valid = !meta.invalid; // put the original value on meta incase the coerced one differs\n\n    meta.value = bindingProps.value;\n    return meta;\n  };\n\n  _proto.handleValidateField = function handleValidateField(event, args) {\n    var _this$props3 = this.props,\n        name = _this$props3.name,\n        validates = _this$props3.validates,\n        actions = _this$props3.actions,\n        noValidate = _this$props3.noValidate;\n    if (noValidate || !actions) return;\n    var fieldsToValidate = validates != null ? [].concat(validates) : [name];\n    actions.onValidate(fieldsToValidate, event, args);\n  };\n\n  _proto.render = function render() {\n    var _this$props4 = this.props,\n        name = _this$props4.name,\n        type = _this$props4.type,\n        children = _this$props4.children,\n        className = _this$props4.className,\n        fieldRef = _this$props4.fieldRef,\n        noMeta = _this$props4.noMeta,\n        noValidate = _this$props4.noValidate,\n        noResolveType = _this$props4.noResolveType,\n        bindingProps = _this$props4.bindingProps,\n        actions = _this$props4.actions,\n        Input = _this$props4.as,\n        asProps = _this$props4.asProps,\n        _this$props4$events = _this$props4.events,\n        events = _this$props4$events === void 0 ? _config.default.events : _this$props4$events;\n    var meta = this.buildMeta();\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== \"production\" ? (0, _warning.default)(!actions || noValidate || !name || meta.schema, \"There is no corresponding schema defined for this field: \\\"\" + name + \"\\\" \" + \"Each Field's `name` prop must be a valid path defined by the parent Form schema\") : void 0;\n    }\n\n    var resolvedType = type || meta.schema && meta.schema._type;\n    meta.resolvedType = resolvedType; // console.log(meta, events(meta))\n\n    var eventHandlers = this.getEventHandlers(typeof events === 'function' ? events(meta) : events);\n\n    var fieldProps = _extends({\n      name: name,\n      type: type\n    }, (0, _omit.default)(this.props, Object.keys(Field.propTypes)), bindingProps, eventHandlers); // ensure that no inputs are left uncontrolled\n\n\n    var value = bindingProps.value === undefined ? null : bindingProps.value;\n    fieldProps.value = value;\n\n    if (!noValidate) {\n      fieldProps.className = (0, _classnames.default)(className, meta.invalid && meta.errorClass);\n    }\n\n    if (!noMeta) fieldProps.meta = meta;\n    if (fieldRef) fieldProps.ref = fieldRef; // Escape hatch for more complex Field types.\n\n    if (typeof children === 'function') {\n      fieldProps.type = resolveToNativeType(resolvedType);\n      return children(fieldProps);\n    } // in the case of a plain input do some schema -> native type mapping\n\n\n    if (Input === 'input' && !type) {\n      fieldProps.type = resolveToNativeType(resolvedType);\n    }\n\n    return _react.default.createElement(Input, _extends({}, asProps, fieldProps, getValueProps(fieldProps.type, value, this.props)), children);\n  };\n\n  return Field;\n}(_react.default.PureComponent);\n\nField.defaultProps = {\n  as: 'input',\n  exclusive: false,\n  fieldRef: null\n};\nField.propTypes = {\n  /**\n   * The Field name, which should be path corresponding to a specific form `value` path.\n   *\n   * ```js\n   * // given the form value\n   * value = {\n   *   name: { first: '' }\n   *   languages: ['english', 'spanish']\n   * }\n   *\n   * // the path \"name.first\" would update the \"first\" property of the form value\n   * <Form.Field name='name.first' />\n   *\n   * // use indexes for paths that cross arrays\n   * <Form.Field name='languages[0]' />\n   *\n   * ```\n   */\n  name: _propTypes.default.string.isRequired,\n\n  /**\n   * The Component Input the form should render. You can sepcify a native element such as 'textbox' or 'select'\n   * or provide a Component type class directly. When no type is provided the Field will attempt determine\n   * the correct input from the Field's schema. A Field corresponding to a `yup.number()`\n   * will render a `type='number'` input by default.\n   *\n   * ```jsx { \"editable\": true }\n   * <Form noValidate schema={modelSchema}>\n   *   Use the schema to determine type\n   *   <Form.Field\n   *     name='dateOfBirth'\n   *     placeholder='date'\n   *   />\n   *\n   *   Override it!\n   *   <Form.Field\n   *     name='dateOfBirth'\n   *     type='time'\n   *     placeholder='time only'\n   *   />\n   *\n   *   Use a custom Component\n   *   (need native 'datetime' support to see it)\n   *   <Form.Field\n   *     name='dateOfBirth'\n   *     as={MyDateInput}/>\n   *\n   * </Form>\n   * ```\n   *\n   * Custom Inputs should comply with the basic input api contract: set a value via a `value` prop and\n   * broadcast changes to that value via an `onChange` handler.\n   */\n  as: _propTypes.default.oneOfType([_elementType.default, _propTypes.default.string]),\n\n  /**\n   * Event name or array of event names that the Field should trigger a validation.\n   * You can also specify a function that receives the Field `meta` object and returns an array of events\n   * in order to change validation strategies based on validity.\n   */\n  events: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.func]),\n\n  /**\n   * Customize how the Field value maps to the overall Form `value`.\n   * `mapFromValue` can be a a string property name or a function that returns a\n   * value for `name`'d path, allowing you to set commuted values from the Field.\n   *\n   * ```js\n   * <Form.Field\n   *   name='name'\n   *   mapFromValue={fieldValue => fieldValue.first + ' ' + fieldValue.last}\n   * />\n   * ```\n   *\n   * You can also provide an object hash, mapping paths of the Form `value`\n   * to fields in the field value using a string field name, or a function accessor.\n   *\n   * ```js { \"editable\": true }\n   * <Form\n   *   schema={modelSchema}\n   *   defaultValue={modelSchema.default()}\n   * >\n   *   <label htmlFor=\"ex-mapToValue-firstName\">Name</label>\n   *   <Form.Field\n   *     name='name.first'\n   *     placeholder='First name'\n   *     id=\"ex-mapToValue-firstName\"\n   *   />\n   *\n   *   <label htmlFor=\"ex-mapToValue-dob\">Date of Birth</label>\n   *   <Form.Field\n   *     name='dateOfBirth'\n   *     id=\"ex-mapToValue-dob\"\n   *     mapFromValue={{\n   *       'dateOfBirth': date => date,\n   *       'age': date =>\n   *         (new Date()).getFullYear() - date.getFullYear()\n   *   }}/>\n   *\n   *   <label htmlFor=\"ex-mapToValue-age\">Age</label>\n   *   <Form.Field name='age' id=\"ex-mapToValue-age\"/>\n   *\n   *   <Form.Submit type='submit'>Submit</Form.Submit>\n   * </Form>\n   * ```\n   */\n  mapFromValue: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.string, _propTypes.default.object]),\n\n  /**\n   * Map the Form value to the Field value. By default\n   * the `name` of the Field is used to extract the relevant\n   * property from the Form value.\n   *\n   * ```js\n   * <Form.Field\n   *   name='location'\n   *   type=\"dropdownlist\"\n   *   mapToValue={model=> pick(model, 'location', 'locationId')}\n   * />\n   * ```\n   */\n  mapToValue: _propTypes.default.func,\n\n  /**\n   * The css class added to the Field Input when it fails validation\n   */\n  errorClass: _propTypes.default.string,\n\n  /**\n   * Tells the Field to trigger validation for specific paths.\n   * Useful when used in conjuction with a `mapFromValue` hash that updates more than one value, or\n   * if you want to trigger validation for the parent path as well.\n   *\n   * > NOTE! This overrides the default behavior of validating the field itself by `name`,\n   * include the `name` if you want the field to validate itself.\n   *\n   * ```jsx\n   * <Form.Field name='name.first' validates=\"name.last\" />\n   * <Form.Field name='name' validates={['name', 'surname']} />\n   * ```\n   */\n  validates: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.arrayOf(_propTypes.default.string)]),\n\n  /**\n   * Indicates whether child fields of the named field\n   * affect the active state ofthe field.\n   *\n   * ```js\n   * -> 'names'\n   * -> 'names.first'\n   * -> 'names.last'\n   * ```\n   *\n   * Are all considered \"part\" of a field named `'names'` by default.\n   */\n  exclusive: _propTypes.default.bool,\n\n  /**\n   * Disables validation for the Field.\n   */\n  noValidate: _propTypes.default.bool,\n\n  /**\n   * When children is the traditional react element or nodes, they are\n   * passed through as-is to the Field `type` component.\n   *\n   * ```jsx\n   * <Field type='select'>\n   *   <option>red</option>\n   *   <option>red</option>\n   * </Field>\n   * ```\n   *\n   * When `children` is a function, its called with the processed field\n   * props and the resolved Field Input component, for more advanced use cases\n   *\n   * ```jsx\n   * <Field name='birthDate'>\n   *  {(props, Input) =>\n   *    <DataProvider>\n   *      <Input {...props} />\n   *    </DataProvider>\n   *  }\n   * </Field>\n   * ```\n   */\n  children: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),\n\n  /**\n   * Instruct the field to not inject the `meta` prop into the input\n   */\n  noMeta: _propTypes.default.bool,\n\n  /**\n   * Attach a ref to the rendered input component\n   */\n  fieldRef: _propTypes.default.func,\n\n  /** @private */\n  noResolveType: _propTypes.default.bool,\n\n  /** @private */\n  bindingProps: _propTypes.default.object,\n\n  /** @private */\n  yupContext: _propTypes.default.any,\n\n  /** @private */\n  errors: _propTypes.default.object,\n\n  /** @private */\n  touched: _propTypes.default.bool,\n\n  /** @private */\n  actions: _propTypes.default.object,\n\n  /** @private */\n  submits: _propTypes.default.shape({\n    submitAttempts: _propTypes.default.number,\n    submitCount: _propTypes.default.number,\n    submitting: _propTypes.default.bool\n  })\n};\n\nvar _default = (0, _Contexts.withState)(function (ctx, props, ref) {\n  var mapToValue = props.mapToValue,\n      mapFromValue = props.mapFromValue,\n      name = props.name,\n      fieldRef = props.fieldRef,\n      rest = _objectWithoutPropertiesLoose(props, [\"mapToValue\", \"mapFromValue\", \"name\", \"fieldRef\"]);\n\n  return _react.default.createElement(_topeka.Binding, {\n    bindTo: mapToValue || name,\n    mapValue: mapFromValue\n  }, function (bindingProps) {\n    return _react.default.createElement(_Contexts.FormActionsContext.Consumer, null, function (actions) {\n      var _extends2;\n\n      return _react.default.createElement(Field, _extends({}, rest, (_extends2 = {\n        name: name,\n        actions: actions,\n        fieldRef: fieldRef || ref,\n        bindingProps: bindingProps,\n        errors: ctx.errors,\n        yupContext: ctx.yupContext,\n        noValidate: ctx.noValidate,\n        submits: ctx.submits,\n        touched: ctx.touched[name]\n      }, _extends2[\"noValidate\"] = props.noValidate == null ? ctx.noValidate : props.noValidate, _extends2)));\n    });\n  });\n}, _Contexts.FORM_DATA.ERRORS | _Contexts.FORM_DATA.TOUCHED | _Contexts.FORM_DATA.SUBMITS | _Contexts.FORM_DATA.YUP_CONTEXT | _Contexts.FORM_DATA.NO_VALIDATE);\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}