{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _ErrorUtils = require(\"./utils/ErrorUtils\");\n\nvar _Field = _interopRequireDefault(require(\"./Field\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction filter(errors, baseName) {\n  var paths = Object.keys(errors || {});\n  var result = {};\n  paths.forEach(function (path) {\n    if (path.indexOf(baseName) !== 0) return;\n    result[path] = errors[path];\n  });\n  return result;\n}\n/**\n * A specialized `Form.Field` component that helps with common list manipulations.\n * Provide a `name`, like normal, to the field with the array and `<FieldArray>` will\n * inject a set of special `arrayHelpers` for handling removing, reordering,\n * editing and adding new items, as well as any error handling quirks that come with those\n * operations.\n *\n * ```js { \"editable\": true }\n * const schema = yup.object({\n *   friends: yup.array().of(\n *     yup.object({\n *       name: yup.string().required()\n *     })\n *   )\n * });\n *\n * render(\n *  <Form\n *   debug\n *   schema={schema}\n *   defaultValue={{\n *     friends: [{ name: 'Sally'}]\n *   }}\n * >\n *   <Form.FieldArray name=\"friends\" events=\"blur\">\n *    {({ value, arrayHelpers }) => (\n *       <ul>\n *        {value.map((item, idx) => (\n *          <li key={idx} >\n *            <div style={{ display: 'flex', alignItems: 'flex-start' }}>\n *              <Form.Field name={`friends[${idx}].name`} />\n *              <button type=\"button\" onClick={() => arrayHelpers.remove(item)}>-</button>\n *              <button type=\"button\" onClick={() => arrayHelpers.add({ name: undefined })}>+</button>\n *            </div>\n *            <Form.Message for={`friends[${idx}].name`} />\n *          </li>\n *        ))}\n *       </ul>\n *     )}\n *   </Form.FieldArray>\n * </Form>\n * )\n * ```\n *\n */\n\n\nvar FieldArray =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(FieldArray, _React$Component);\n\n  function FieldArray() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _this.onAdd = function (item) {\n      var value = _this.fieldProps.value;\n\n      _this.onInsert(item, value ? value.length : 0);\n    };\n\n    _this.onUpdate = function (updatedItem, oldItem) {\n      var _this$fieldProps = _this.fieldProps,\n          value = _this$fieldProps.value,\n          onChange = _this$fieldProps.onChange;\n      var index = value.indexOf(oldItem);\n      var newValue = value == null ? [] : value.concat();\n      newValue.splice(index, 1, updatedItem);\n      onChange(newValue);\n    };\n\n    _this.onInsert = function (item, index) {\n      var _this$fieldProps2 = _this.fieldProps,\n          value = _this$fieldProps2.value,\n          onChange = _this$fieldProps2.onChange;\n      var newValue = value == null ? [] : value.concat();\n      newValue.splice(index, 0, item);\n      onChange(newValue);\n\n      _this.sendErrors(function (errors, name) {\n        return (0, _ErrorUtils.unshift)(errors, name, index);\n      });\n    };\n\n    _this.onMove = function (item, toIndex) {\n      var _this$fieldProps3 = _this.fieldProps,\n          value = _this$fieldProps3.value,\n          onChange = _this$fieldProps3.onChange;\n      var fromIndex = value.indexOf(item);\n      var newValue = value == null ? [] : value.concat();\n      !(fromIndex !== -1) ? process.env.NODE_ENV !== \"production\" ? (0, _invariant.default)(false, '`onMove` must be called with an item in the array') : invariant(false) : void 0;\n      newValue.splice.apply(newValue, [toIndex, 0].concat(newValue.splice(fromIndex, 1))); // FIXME: doesn't handle syncing error state.\n\n      onChange(newValue, {\n        action: 'move',\n        toIndex: toIndex,\n        fromIndex: fromIndex\n      });\n\n      _this.sendErrors(function (errors, name) {\n        return (0, _ErrorUtils.move)(errors, name, fromIndex, toIndex);\n      });\n    };\n\n    _this.onRemove = function (item) {\n      var _this$fieldProps4 = _this.fieldProps,\n          value = _this$fieldProps4.value,\n          onChange = _this$fieldProps4.onChange;\n      if (value == null) return;\n      var index = value.indexOf(item);\n      onChange(value.filter(function (v) {\n        return v !== item;\n      }));\n\n      _this.sendErrors(function (errors, name) {\n        return (0, _ErrorUtils.shift)(errors, name, index);\n      });\n    };\n\n    _this.mapValues = function (fn) {\n      var _this$fieldProps5 = _this.fieldProps,\n          value = _this$fieldProps5.value,\n          name = _this$fieldProps5.name;\n      return value.map(function (item, index) {\n        return fn(item, name + \"[\" + index + \"]\", index);\n      });\n    };\n\n    _this.items = function () {\n      var _this$fieldProps6 = _this.fieldProps,\n          values = _this$fieldProps6.value,\n          name = _this$fieldProps6.name;\n      return !values ? [] : values.map(function (value, index) {\n        var itemName = name + \"[\" + index + \"]\";\n        var itemErrors = filter(_this.meta.errors, itemName);\n        return {\n          value: value,\n          name: itemName,\n          onChange: function onChange(item) {\n            return _this.onUpdate(item, values[index]);\n          },\n          meta: _extends({}, _this.meta, {\n            errors: itemErrors,\n            valid: !Object.keys(itemErrors).length,\n            invalid: !!Object.keys(itemErrors).length,\n            onError: function onError(errors) {\n              return _this.onItemError(itemName, errors);\n            }\n          })\n        };\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = FieldArray.prototype;\n\n  _proto.onItemError = function onItemError(name, errors) {\n    this.sendErrors(function (fieldErrors) {\n      return _extends({}, (0, _ErrorUtils.remove)(fieldErrors, name), errors);\n    });\n  };\n\n  _proto.sendErrors = function sendErrors(fn) {\n    var name = this.fieldProps.name;\n    var _this$meta = this.meta,\n        errors = _this$meta.errors,\n        onError = _this$meta.onError;\n    onError(fn(errors || {}, name));\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        fieldProps = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n\n    return _react.default.createElement(_Field.default, fieldProps, function (_ref) {\n      var meta = _ref.meta,\n          props = _objectWithoutPropertiesLoose(_ref, [\"meta\"]);\n\n      _this2.fieldProps = props;\n      _this2.meta = meta;\n\n      var nextProps = _extends({}, props, {\n        meta: meta,\n        arrayHelpers: {\n          items: _this2.items,\n          add: _this2.onAdd,\n          move: _this2.onMove,\n          insert: _this2.onInsert,\n          remove: _this2.onRemove,\n          update: _this2.onUpdate\n        }\n      });\n\n      return typeof children === 'function' ? children(nextProps) : _react.default.cloneElement(children, nextProps);\n    });\n  };\n\n  return FieldArray;\n}(_react.default.Component);\n\nFieldArray.propTypes = {\n  name: _propTypes.default.string.isRequired,\n\n  /**\n   * The same signature as providing a function to `<Field>` but with an\n   * additional `arrayHelpers` object passed to the render function\n   *\n   * @type {Function}\n   */\n  children: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.element])\n};\nvar _default = FieldArray;\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}