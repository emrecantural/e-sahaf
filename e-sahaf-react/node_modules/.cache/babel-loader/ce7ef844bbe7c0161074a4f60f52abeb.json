{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = exports.Consumer = exports.Provider = void 0;\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _uncontrollable = _interopRequireDefault(require(\"uncontrollable\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _propertyExpr = _interopRequireDefault(require(\"property-expr\"));\n\nvar _updateIn = _interopRequireDefault(require(\"./updateIn\"));\n\nvar defaultSetter = function defaultSetter(path, model, val) {\n  return (0, _updateIn.default)(model, path, val);\n};\n\nfunction wrapSetter(setter) {\n  return function () {\n    var result = setter.apply(void 0, arguments);\n    !(result && typeof result === 'object') ? process.env.NODE_ENV !== \"production\" ? (0, _invariant.default)(false, '`setter(..)` props must return the form value object after updating a value.') : invariant(false) : void 0;\n    return result;\n  };\n}\n\nvar _React$createContext = _react.default.createContext({\n  getValue: function getValue() {},\n  updateBindingValue: function updateBindingValue() {}\n}),\n    Provider = _React$createContext.Provider,\n    Consumer = _React$createContext.Consumer;\n\nexports.Consumer = Consumer;\nexports.Provider = Provider;\n\nvar BindingContext =\n/*#__PURE__*/\nfunction (_React$Component) {\n  (0, _inheritsLoose2.default)(BindingContext, _React$Component);\n\n  BindingContext.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var value = _ref.value,\n        getter = _ref.getter;\n\n    if (value === prevState.value && getter === prevState.getter) {\n      return null;\n    }\n\n    return {\n      value: value,\n      getter: getter,\n      bindingContext: {\n        updateBindingValue: prevState.bindingContext.updateBindingValue,\n        getValue: function getValue(pathOrAccessor) {\n          return typeof pathOrAccessor === 'function' ? pathOrAccessor(value, getter) : getter(pathOrAccessor, value);\n        }\n      }\n    };\n  };\n\n  function BindingContext() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n\n    _this.updateBindingValue = function (mapValue, args) {\n      var _this$props = _this.props,\n          model = _this$props.value,\n          updater = _this$props.setter,\n          onChange = _this$props.onChange;\n      var paths = [];\n      if (process.env.NODE_ENV !== 'production') updater = wrapSetter(updater);\n      Object.keys(mapValue).forEach(function (key) {\n        var field = mapValue[key],\n            value;\n        if (typeof field === 'function') value = field.apply(void 0, args);else if (field === '.' || field == null || args[0] == null) value = args[0];else {\n          value = _propertyExpr.default.getter(field, true)(args[0]);\n        }\n        if (paths.indexOf(key) === -1) paths.push(key);\n        model = updater(key, model, value, defaultSetter);\n      });\n      onChange(model, paths);\n    };\n\n    _this.state = {\n      bindingContext: {\n        updateBindingValue: _this.updateBindingValue\n      }\n    };\n    return _this;\n  }\n\n  var _proto = BindingContext.prototype;\n\n  _proto.render = function render() {\n    return _react.default.createElement(Provider, {\n      value: this.state.bindingContext\n    }, this.props.children);\n  };\n\n  return BindingContext;\n}(_react.default.Component);\n\nBindingContext.propTypes = {\n  /**\n   * BindingContext value object, can be left uncontrolled;\n   * use the `defaultValue` prop to initialize an uncontrolled BindingContext.\n   *\n   * BindingContext assumes that `value` is immutable so you must provide a _new_ value\n   * object to trigger an update. The `<Binding/>` components do this by default.\n   */\n  value: _propTypes.default.object,\n\n  /**\n   * Callback that is called when the `value` prop changes.\n   *\n   * ```js\n   * function(\n   * \tvalue: object,\n   * \tupdatedPaths: array<string>\n   * )\n   * ```\n   */\n  onChange: _propTypes.default.func,\n\n  /**\n   * A function used to extract value paths from the Context value.\n   * `getter` is called with `path` and `value` and should return the value at that path.\n   * `getter()` is used when a `<Binding/>` provides a string `accessor`.\n   *\n   * ```js\n   * function(\n   *  path: string,\n   *  value: any,\n   * ) -> object\n   * ```\n   */\n  getter: _propTypes.default.func,\n\n  /**\n   * A value setter function. `setter` is called with `path`, the context `value` and the path `value`.\n   * The `setter` must return updated form `value`, which allows you to leave the original value unmutated.\n   *\n   * ```js\n   * function(\n   *  path: string,\n   *  formValue: object,\n   *  pathValue: any\n   * ) -> object\n   * ```\n   */\n  setter: _propTypes.default.func\n};\nBindingContext.defaultProps = {\n  getter: function getter(path, model) {\n    return path ? _propertyExpr.default.getter(path, true)(model || {}) : model;\n  },\n  setter: defaultSetter\n};\n\nvar _default = (0, _uncontrollable.default)(BindingContext, {\n  value: 'onChange',\n  touched: 'onTouch'\n});\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}