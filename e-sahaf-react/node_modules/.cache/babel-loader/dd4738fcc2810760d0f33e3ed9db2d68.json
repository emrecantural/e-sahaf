{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _topeka = require(\"topeka\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _propertyExpr = _interopRequireDefault(require(\"property-expr\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _uncontrollable = _interopRequireDefault(require(\"uncontrollable\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _warning = _interopRequireDefault(require(\"warning\"));\n\nvar _elementType = _interopRequireDefault(require(\"prop-types-extra/lib/elementType\"));\n\nvar _reach = _interopRequireDefault(require(\"yup/lib/util/reach\"));\n\nvar _shallowequal = _interopRequireDefault(require(\"shallowequal\"));\n\nvar _errorManager = _interopRequireDefault(require(\"./errorManager\"));\n\nvar _errToJSON = _interopRequireDefault(require(\"./utils/errToJSON\"));\n\nvar ErrorUtils = _interopRequireWildcard(require(\"./utils/ErrorUtils\"));\n\nvar _Contexts = require(\"./Contexts\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar batchedUpdates = _reactDom.default.unstable_batchedUpdates || function (fn) {\n  return fn();\n};\n\nvar BindingContext = _topeka.BindingContext.ControlledComponent;\n\nvar done = function done(e) {\n  return setTimeout(function () {\n    throw e;\n  });\n};\n\nvar isValidationError = function isValidationError(err) {\n  return err && err.name === 'ValidationError';\n};\n\nvar YUP_OPTIONS = ['context', 'stripUnknown', 'recursive', 'abortEarly', 'strict'];\n\nvar getter = function getter(path, model) {\n  return path ? _propertyExpr.default.getter(path, true)(model || {}) : model;\n};\n\nvar setter = BindingContext.defaultProps.setter;\n/**\n * Form component renders a `value` to be updated and validated by child Fields.\n * Forms can be thought of as `<input/>`s for complex values, or models. A Form aggregates\n * a bunch of smaller inputs, each in charge of updating a small part of the overall model.\n * The Form will integrate and validate each change and fire a single unified `onChange` with the new `value`.\n *\n * Validation errors can be displayed anywhere inside a Form with Message Components.\n *\n * ```jsx { \"editable\": true }\n * var defaultStr = yup.string().default('')\n *\n * var customerSchema = yup\n *   .object({\n *     name: yup.object({\n *       first: defaultStr\n *         .required('please enter a first name'),\n *\n *       last: defaultStr\n *         .required('please enter a surname'),\n *     }),\n *\n *     dateOfBirth: yup.date()\n *       .max(new Date(), \"Are you a time traveler?!\"),\n *\n *     colorId: yup.number()\n *       .nullable()\n *       .required('Please select a dank color')\n *   });\n *\n * render(\n *   <Form\n *     schema={customerSchema}\n *     defaultValue={customerSchema.default()}\n *   >\n *     <div>\n *       {\\/\\*'grandchildren' are no problem \\*\\/}\n *       <label>Name</label>\n *\n *       <Form.Field\n *         name='name.first'\n *         placeholder='First name'\n *       />\n *       <Form.Field\n *         name='name.last'\n *         placeholder='Surname'\n *       />\n *\n *       <Form.Message for={['name.first', 'name.last']} className=\"validation-error\"/>\n *     </div>\n *\n *     <label>Date of Birth</label>\n *     <Form.Field name='dateOfBirth'/>\n *     <Form.Message for='dateOfBirth' className=\"validation-error\"/>\n *\n *     <label>Favorite Color</label>\n *     <Form.Field name='colorId' as='select'>\n *       <option value={null}>Select a color...</option>\n *       <option value={0}>Red</option>\n *       <option value={1}>Yellow</option>\n *       <option value={2}>Blue</option>\n *       <option value={3}>other</option>\n *     </Form.Field>\n *     <Form.Message for='colorId' className=\"validation-error\"/>\n *\n *   <Form.Submit type='submit'>\n *     Submit\n *   </Form.Submit>\n * </Form>)\n * ```\n */\n\nvar Form =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(Form, _React$PureComponent);\n\n  function Form(_props, _context) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, _props, _context) || this;\n\n    _this.getSchemaForPath = function (path, props) {\n      if (props === void 0) {\n        props = _this.props;\n      }\n\n      var _props2 = props,\n          schema = _props2.schema,\n          value = _props2.value,\n          context = _props2.context;\n      return schema && path && (0, _reach.default)(schema, path, value, context);\n    };\n\n    _this.handleChange = function (model, paths) {\n      var _this$props = _this.props,\n          onChange = _this$props.onChange,\n          onTouch = _this$props.onTouch,\n          touched = _this$props.touched;\n      var nextTouched = touched;\n      onChange(model, paths);\n      paths.forEach(function (path) {\n        var _extends2;\n\n        if (touched && touched[path]) return;\n        if (nextTouched === touched) nextTouched = _extends({}, touched, (_extends2 = {}, _extends2[path] = true, _extends2));else nextTouched[path] = true;\n      });\n      if (nextTouched !== touched) onTouch(nextTouched, paths);\n    };\n\n    _this.handleValidationRequest = function (fields, type, args) {\n      var _this$props2 = _this.props,\n          noValidate = _this$props2.noValidate,\n          delay = _this$props2.delay;\n      fields = [].concat(fields);\n      if (noValidate) return;\n\n      _this.notify('onValidate', {\n        type: type,\n        fields: fields,\n        args: args\n      });\n\n      _this.enqueue(fields);\n\n      if (type !== 'onChange') _this.flush(delay);\n    };\n\n    _this.handleFieldError = function (name, fieldErrors) {\n      var errors = _this.props.errors;\n\n      _this.handleError(_extends(ErrorUtils.remove(errors, name), fieldErrors));\n    };\n\n    _this.handleError = function (errors) {\n      _this.notify('onError', errors);\n    };\n\n    _this.handleSubmitSuccess = function (validatedValue) {\n      var submitForm = _this.props.submitForm;\n\n      _this.notify('onSubmit', validatedValue);\n\n      return Promise.resolve(submitForm && submitForm(validatedValue)).then(function () {\n        _this.setSubmitting(false);\n\n        _this.updateFormState(function (s) {\n          return {\n            submits: _extends({}, s.submits, {\n              submitCount: s.submits.submitCount + 1,\n              submitAttempts: s.submits.submitAttempts + 1\n            })\n          };\n        });\n\n        _this.notify('onSubmitFinished');\n      }, function (err) {\n        _this.setSubmitting(false);\n\n        _this.notify('onSubmitFinished', err);\n\n        throw err;\n      });\n    };\n\n    _this.handleSubmitError = function (err) {\n      if (!isValidationError(err)) throw err;\n      var errors = (0, _errToJSON.default)(err);\n      maybeWarn(_this.props.debug, errors, 'onSubmit');\n\n      _this.updateFormState(function (s) {\n        return {\n          submits: _extends({}, s.submits, {\n            submitAttempts: s.submits.submitAttempts + 1\n          })\n        };\n      });\n\n      _this.notify('onError', errors);\n\n      _this.notify('onInvalidSubmit', errors);\n\n      _this.setSubmitting(false);\n    };\n\n    _this.handleSubmit = function (e) {\n      if (e && e.preventDefault) e.preventDefault();\n      clearTimeout(_this.submitTimer);\n      _this.submitTimer = setTimeout(function () {\n        return _this.submit().catch(done);\n      }, 0);\n    };\n\n    _this.updateFormState = function (fn) {\n      batchedUpdates(function () {\n        if (_this.unmounted) return;\n\n        _this.setState(function (_ref) {\n          var formState = _ref.formState;\n          var nextFormState = fn(formState); // TODO: optimize the nullish case\n\n          return nextFormState !== formState && nextFormState !== null ? {\n            formState: _extends({}, formState, nextFormState)\n          } : null;\n        });\n      });\n    };\n\n    _this.submit = function () {\n      var _this$props3 = _this.props,\n          schema = _this$props3.schema,\n          noValidate = _this$props3.noValidate,\n          value = _this$props3.value,\n          onSubmitFinished = _this$props3.onSubmitFinished,\n          errors = _this$props3.errors,\n          options = _objectWithoutPropertiesLoose(_this$props3, [\"schema\", \"noValidate\", \"value\", \"onSubmitFinished\", \"errors\"]);\n\n      if (_this._submitting) {\n        return Promise.resolve(false);\n      }\n\n      options.abortEarly = false;\n      options.strict = false;\n\n      _this.notify('onBeforeSubmit', {\n        value: value,\n        errors: errors\n      });\n\n      _this.setSubmitting(true);\n\n      return (noValidate ? Promise.resolve(true) : schema.validate(value, options)). // no catch, we aren't interested in errors from onSubmit handlers\n      then(_this.handleSubmitSuccess, _this.handleSubmitError).then(onSubmitFinished);\n    };\n\n    _this.debug = function () {\n      var _console;\n\n      if (!_this.props.__debugName) return;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_console = console).log.apply(_console, ['Form:', _this.props.__debugName].concat(args)); // eslint-disable-line\n\n    };\n\n    _this.validatePath = function (path, _ref2) {\n      var props = _ref2.props;\n      var options = (0, _pick.default)(props, YUP_OPTIONS);\n      var abortEarly = options.abortEarly == null ? false : options.abortEarly;\n      var value = props.value,\n          schema = props.schema;\n      return schema.validateAt(path, value, _extends({}, options, {\n        abortEarly: abortEarly\n      })).then(function () {\n        return null;\n      }).catch(function (err) {\n        return err;\n      });\n    };\n\n    _this.queue = [];\n    _this.errors = (0, _errorManager.default)(_this.validatePath);\n    _this.formActions = {\n      onSubmit: _this.handleSubmit,\n      onValidate: _this.handleValidationRequest,\n      onFieldError: _this.handleFieldError,\n      getSchemaForPath: _this.getSchemaForPath\n    };\n    _this.state = {\n      formState: {\n        submits: {\n          submitCount: 0,\n          submitAttempts: 0,\n          submitting: false\n        },\n        value: _this.props.value,\n        errors: _this.props.errors,\n        touched: _this.props.touched\n      }\n    };\n    return _this;\n  }\n\n  Form.getDerivedStateFromProps = function getDerivedStateFromProps(_ref3, _ref4) {\n    var value = _ref3.value,\n        touched = _ref3.touched,\n        errors = _ref3.errors;\n    var formState = _ref4.formState;\n    if (value !== formState.value || touched !== formState.touched || !(0, _shallowequal.default)(formState.errors, errors)) return {\n      formState: _extends({}, formState, {\n        errors: errors,\n        touched: touched,\n        value: value\n      })\n    };\n    return null;\n  };\n\n  var _proto = Form.prototype;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this$props4 = this.props,\n        errors = _this$props4.errors,\n        delay = _this$props4.delay,\n        schema = _this$props4.schema;\n    var schemaChanged = schema !== prevProps.schema;\n\n    if (schemaChanged && errors) {\n      this.enqueue(Object.keys(errors));\n    }\n\n    this.flush(delay);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.unmounted = true;\n    clearTimeout(this.submitTimer);\n    clearTimeout(this.validationTimer);\n  };\n\n  _proto.collectErrors = function collectErrors(fields, props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return this.errors.collect(fields, props.errors, {\n      props: props\n    });\n  };\n\n  _proto.enqueue = function enqueue(fields) {\n    this.queue = this.queue.concat(fields);\n  };\n\n  _proto.flush = function flush(delay) {\n    var _this2 = this;\n\n    clearTimeout(this.validationTimer);\n    this.validationTimer = setTimeout(function () {\n      var fields = _this2.queue;\n      var props = _this2.props;\n      if (!fields.length) return;\n      _this2.queue = [];\n\n      _this2.collectErrors(fields, _this2.props).then(function (errors) {\n        if (errors !== _this2.props.errors) {\n          maybeWarn(props.debug, errors, 'field validation');\n\n          _this2.notify('onError', errors);\n        }\n      }).catch(done);\n    }, delay);\n  };\n\n  _proto.setSubmitting = function setSubmitting(submitting) {\n    if (this.unmounted) return; // this state is duplicated locally because it can take longer for the\n    // submit state to flush than a user can re-submit which we don't want\n\n    this._submitting = submitting;\n    this.updateFormState(function (s) {\n      return s.submits.submitting !== submitting ? {\n        submits: _extends({}, s.submits, {\n          submitting: submitting\n        })\n      } : null;\n    });\n  };\n\n  _proto.notify = function notify(event) {\n    var _this$props5;\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    if (this.props[event]) (_this$props5 = this.props)[event].apply(_this$props5, args);\n  };\n\n  _proto.validate = function validate(fields) {\n    return this.collectErrors(fields);\n  };\n\n  _proto.render = function render() {\n    var _this$props6 = this.props,\n        children = _this$props6.children,\n        value = _this$props6.value,\n        getter = _this$props6.getter,\n        setter = _this$props6.setter,\n        Element = _this$props6.as,\n        _ = _this$props6.onChange,\n        _1 = _this$props6.onTouch,\n        _2 = _this$props6.touched;\n    var props = (0, _omit.default)(this.props, YUP_OPTIONS.concat(Object.keys(Form.propTypes), ['onTouch']));\n    delete props.__debugName;\n    if (Element === 'form') props.noValidate = true; // disable html5 validation\n\n    props.onSubmit = this.handleSubmit;\n\n    if (Element === null || Element === false) {\n      children = _react.default.cloneElement(_react.default.Children.only(children), props);\n    } else {\n      children = _react.default.createElement(Element, props, children);\n    }\n\n    return _react.default.createElement(BindingContext, {\n      value: value,\n      getter: getter,\n      setter: setter,\n      onChange: this.handleChange\n    }, _react.default.createElement(_Contexts.FormActionsContext.Provider, {\n      value: this.formActions\n    }, _react.default.createElement(_Contexts.FormDataContext.Provider, {\n      value: this.state.formState\n    }, children)));\n  };\n\n  return Form;\n}(_react.default.PureComponent);\n\nForm.propTypes = {\n  /**\n   * Form value object, can be left [uncontrolled](/controllables);\n   * use the `defaultValue` prop to initialize an uncontrolled form.\n   */\n  value: _propTypes.default.object,\n\n  /**\n   * Callback that is called when the `value` prop changes.\n   *\n   * ```js\n   * function(\n   *   value: object,\n   *   updatedPaths: array<string>\n   * )\n   * ```\n   */\n  onChange: _propTypes.default.func,\n\n  /**\n   * An object hash of field errors for the form. The object should be keyed with paths\n   * with the values being an array of errors or message objects. Errors can be\n   * left [uncontrolled](/controllables) (use `defaultErrors` to set an initial value)\n   * or managed along with the `onError` callback. You can use any object shape you'd like for\n   * errors, as long as you provide the Form.Message component an `extract` prop that\n   * understands how to pull out the strings message. By default it understands strings and objects\n   * with a `'message'` property.\n   *\n   * ```js\n   * <Form errors={{\n   *  \"name.first\": [\n   *    'First names are required',\n   *    {\n   *    \tmessage: \"Names must be at least 2 characters long\",\n   *    \ttype: 'min'\n   *    }\n   *  ],\n   * }}/>\n   * ```\n   */\n  errors: _propTypes.default.object,\n\n  /**\n   * Callback that is called when a validation error occurs. It is called with an `errors` object\n   *\n   * ```jsx { \"editable\": true }\n   * class Example extends React.Component {\n   *   constructor(props) {\n   *     this.state = { errors: {} }\n   *   }\n   *   render() {\n   *     return (\n   *       <Form\n   *         schema={modelSchema}\n   *         defaultValue={modelSchema.default()}\n   *         errors={this.state.errors}\n   *         onError={errors => {\n   *           if( errors.dateOfBirth )\n   *             errors.dateOfBirth = 'hijacked!'\n   *           this.setState({ errors })\n   *       }}>\n   *\n   *         <Form.Field name='dateOfBirth'/>\n   *         <Form.Message for='dateOfBirth'/>\n   *\n   *         <Form.Submit type='submit'>Submit</Form.Submit>\n   *       </Form>\n   *     )\n   *   }\n   * }\n   *\n   * render(<Example />)\n   * ```\n   */\n  onError: _propTypes.default.func,\n\n  /**\n   * Callback that is called whenever a validation is triggered.\n   * It is called _before_ the validation is actually run.\n   * ```js\n   * function onValidate(event){\n   *   let { type, fields, args } = event\n   * }\n   * ```\n   */\n  onValidate: _propTypes.default.func,\n\n  /**\n   * Callback that is fired in response to a submit, _before validation runs.\n   *\n   * ```js\n   * function onSubmit(formValue){\n   *   // do something with valid value\n   * }\n   * ```\n   */\n  onBeforeSubmit: _propTypes.default.func,\n\n  /**\n   * Callback that is fired in response to a submit, after validation runs for the entire form.\n   *\n   * ```js\n   * function onSubmit(formValue){\n   *   // do something with valid value\n   * }\n   * ```\n   */\n  onSubmit: _propTypes.default.func,\n  onSubmitFinished: _propTypes.default.func,\n\n  /* */\n  submitForm: _propTypes.default.func,\n\n  /**\n   * Callback that is fired when the native onSubmit event is triggered. Only relevant when\n   * the `component` prop renders a `<form/>` tag. onInvalidSubmit will trigger only if the form is invalid.\n   *\n   * ```js\n   * function onInvalidSubmit(errors){\n   *   // do something with errors\n   * }\n   * ```\n   */\n  onInvalidSubmit: _propTypes.default.func,\n\n  /**\n   * A value getter function. `getter` is called with `path` and `value` and\n   * should return the plain **javascript** value at the path.\n   *\n   * ```ts\n   * function(\n   *  path: string,\n   *  value: any,\n   * ): Object\n   * ```\n   */\n  getter: _propTypes.default.func,\n\n  /**\n   * A value setter function. `setter` is called with `path`, the form `value` and the path `value`.\n   * The `setter` must return updated form `value`, which allows you to leave the original value unmutated.\n   *\n   * The default implementation uses the [react immutability helpers](http://facebook.github.io/react/docs/update.html),\n   * letting you treat the form `value` as immutable.\n   * ```js\n   * function(\n   *  path: string,\n   *  formValue: object,\n   *  pathValue: any\n   * ) -> object\n   * ```\n   */\n  setter: _propTypes.default.func,\n\n  /**\n   * Time in milliseconds that validations should be debounced. Reduces the amount of validation calls\n   * made at the expense of a slight delay. Helpful for performance.\n   */\n  delay: _propTypes.default.number,\n\n  /**\n   * Validations will be strict, making no attempt to coarce input values to the appropriate type.\n   */\n  strict: _propTypes.default.bool,\n\n  /**\n   * Turns off input validation for the Form, value updates will continue to work.\n   */\n  noValidate: _propTypes.default.bool,\n\n  /**\n   * A tag name or Component class the Form should render.\n   *\n   * If `null` are `false` the form will simply render it's child. In\n   * this instance there must only be one child.\n   */\n  as: _propTypes.default.oneOfType([_elementType.default, _propTypes.default.oneOf([null, false])]),\n\n  /**\n   * A Yup schema  that validates the Form `value` prop. Used to validate the form input values\n   * For more information about the yup api check out: https://github.com/jquense/yup/blob/master/README.md\n   * @type {YupSchema}\n   */\n  schema: function schema(props, name, componentName) {\n    var _PropTypes$any;\n\n    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      args[_key3 - 3] = arguments[_key3];\n    }\n\n    var err = !props.noValidate && (_PropTypes$any = _propTypes.default.any).isRequired.apply(_PropTypes$any, [props, name, componentName].concat(args));\n\n    if (props[name]) {\n      var schema = props[name];\n      if (!schema.__isYupSchema__ && !(schema.resolve && schema.validate)) err = new Error('`schema` must be a proper yup schema: (' + componentName + ')');\n    }\n\n    return err;\n  },\n\n  /**\n   * yup schema context\n   */\n  context: _propTypes.default.object,\n\n  /**\n   * toggle debug mode, which `console.warn`s validation errors\n   */\n  debug: _propTypes.default.bool\n};\nForm.defaultProps = _extends({}, BindingContext.defaultProps, {\n  as: 'form',\n  strict: false,\n  delay: 300,\n  errors: ErrorUtils.EMPTY_ERRORS,\n  touched: {},\n  getter: getter,\n  setter: setter\n});\n\nfunction maybeWarn(debug, errors, target) {\n  if (!debug) return;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var keys = Object.keys(errors);\n    process.env.NODE_ENV !== \"production\" ? (0, _warning.default)(!keys.length, \"[react-formal] (\" + target + \") invalid fields: \" + keys.join(', ')) : void 0;\n  }\n}\n\nvar ControlledForm = (0, _uncontrollable.default)(Form, {\n  value: 'onChange',\n  errors: 'onError',\n  touched: 'onTouch'\n});\nControlledForm.getter = getter;\nControlledForm.setter = setter;\nvar _default = ControlledForm;\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}