{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.prefix = prefix;\nexports.unprefix = unprefix;\nexports.pickErrors = pickErrors;\nexports.filter = filter;\nexports.filterAndMapErrors = filterAndMapErrors;\nexports.remove = remove;\nexports.shift = shift;\nexports.unshift = unshift;\nexports.move = move;\nexports.swap = swap;\nexports.inclusiveMapErrors = inclusiveMapErrors;\nexports.isChildPath = exports.EMPTY_ERRORS = void 0;\n\nvar _omitBy = _interopRequireDefault(require(\"lodash/omitBy\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _paths = require(\"./paths\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EMPTY_ERRORS = Object.freeze({});\nexports.EMPTY_ERRORS = EMPTY_ERRORS;\n\nvar isChildPath = function isChildPath(basePath, path) {\n  return path !== basePath && (0, _paths.inPath)(basePath, path);\n};\n\nexports.isChildPath = isChildPath;\n\nfunction mapKeys(errors, baseName, fn) {\n  if (errors === EMPTY_ERRORS) return errors;\n  var newErrors = {};\n  var workDone = false;\n  Object.keys(errors).forEach(function (path) {\n    var newKey = path;\n\n    if (isChildPath(baseName, path)) {\n      var matches = path.slice(baseName.length).match(/\\[(\\d+)\\](.*)$/);\n      newKey = fn(+matches[1], matches[2] || '', path);\n      if (!workDone && newKey !== path) workDone = true;\n    }\n\n    newErrors[newKey] = errors[path];\n  });\n  return workDone ? newErrors : errors;\n}\n\nvar prefixName = function prefixName(name, baseName) {\n  return baseName + (!name || name[0] === '[' ? '' : '.') + name;\n};\n\nfunction prefix(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    result[prefixName(path, baseName)] = errors[path];\n  });\n  return result;\n}\n\nfunction unprefix(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    var shortened = path.slice(baseName.length).replace(/^\\./, '');\n    result[shortened] = errors[path];\n  });\n  return result;\n}\n\nfunction pickErrors(errors, names) {\n  if (!names.length) return errors;\n  return (0, _pick.default)(errors, names);\n}\n\nfunction filter(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    if (isChildPath(baseName, path)) {\n      result[path] = errors[path];\n    }\n  });\n  return result;\n}\n\nfunction filterAndMapErrors(_ref) {\n  var errors = _ref.errors,\n      names = _ref.names,\n      resolveNames = _ref.resolveNames,\n      _ref$mapErrors = _ref.mapErrors,\n      mapErrors = _ref$mapErrors === void 0 ? pickErrors : _ref$mapErrors;\n  if (!errors || errors === EMPTY_ERRORS) return errors;\n  names = resolveNames ? resolveNames() : names;\n  return mapErrors(errors, names ? [].concat(names) : []);\n}\n\nfunction remove(errors) {\n  for (var _len = arguments.length, basePaths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    basePaths[_key - 1] = arguments[_key];\n  }\n\n  return (0, _omitBy.default)(errors, function (_, path) {\n    return basePaths.some(function (b) {\n      return (0, _paths.inPath)(b, path);\n    });\n  });\n}\n\nfunction shift(errors, baseName, atIndex) {\n  var current = baseName + \"[\" + atIndex + \"]\";\n  return mapKeys(remove(errors, current), baseName, function (index, tail) {\n    if (index > atIndex) {\n      return baseName + \"[\" + (index - 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction unshift(errors, baseName, atIndex) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (index > atIndex) {\n      return baseName + \"[\" + (index + 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction move(errors, baseName, fromIndex, toIndex) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (fromIndex > toIndex) {\n      if (index === fromIndex) return baseName + \"[\" + toIndex + \"]\" + tail; // increment everything above the pivot\n\n      if (index >= toIndex && index < fromIndex) return baseName + \"[\" + (index + 1) + \"]\" + tail;\n    } else if (fromIndex < toIndex) {\n      if (index === fromIndex) return baseName + \"[\" + toIndex + \"]\" + tail; // decrement everything above the from item we moved\n\n      if (index >= fromIndex && index < toIndex) return baseName + \"[\" + (index - 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction swap(errors, baseName, indexA, indexB) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (index === indexA) return baseName + \"[\" + indexB + \"]\" + tail;\n    if (index === indexB) return baseName + \"[\" + indexA + \"]\" + tail;\n    return null;\n  });\n}\n\nfunction inclusiveMapErrors(errors, names) {\n  if (!names.length || errors === EMPTY_ERRORS) return EMPTY_ERRORS;\n  var activeErrors = {};\n  var paths = Object.keys(errors);\n  names.forEach(function (name) {\n    paths.forEach(function (path) {\n      if (errors[path] && (0, _paths.inPath)(name, path)) {\n        activeErrors[path] = errors[path];\n      }\n    });\n  });\n  return activeErrors;\n}","map":null,"metadata":{},"sourceType":"script"}